"use server"

import { prisma } from "@/lib/db"
import { getOrCreateSession } from "@/lib/session"
import { revalidatePath } from "next/cache"

interface PrepPackContent {
  sections: Array<{
    name: string
    marks: number
    questions: Array<{
      id: string
      text: string
      marks?: number
      answer?: string
      type: string
    }>
  }>
  formulas?: string[]
  tips?: string[]
  summary?: string
}

// Generate PDF content as base64 using jsPDF (client-side compatible)
export async function generatePrepPackPDFContent(prepPackId: string) {
  const sessionId = await getOrCreateSession()

  const prepPack = await prisma.prepPack.findFirst({
    where: { id: prepPackId, sessionId },
  })

  if (!prepPack) {
    return { success: false, error: "Prep pack not found" }
  }

  const content = JSON.parse(prepPack.content) as PrepPackContent
  const config = JSON.parse(prepPack.config)

  // Return structured data for client-side PDF generation
  return {
    success: true,
    data: {
      title: prepPack.title,
      subject: prepPack.subject,
      totalMarks: prepPack.totalMarks,
      content,
      config,
      createdAt: prepPack.createdAt.toISOString(),
    },
  }
}

// Generate HTML content for preview
export async function generatePrepPackPreview(prepPackId: string) {
  const sessionId = await getOrCreateSession()

  const prepPack = await prisma.prepPack.findFirst({
    where: { id: prepPackId, sessionId },
  })

  if (!prepPack) {
    return { success: false, error: "Prep pack not found" }
  }

  const content = JSON.parse(prepPack.content) as PrepPackContent

  let html = `
    <div class="prep-pack-preview" style="font-family: system-ui, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px;">
      <div style="text-align: center; margin-bottom: 30px; border-bottom: 2px solid #333; padding-bottom: 20px;">
        <h1 style="margin: 0; font-size: 24px;">${prepPack.title}</h1>
        <p style="color: #666; margin: 10px 0;">Subject: ${prepPack.subject} | Total Marks: ${prepPack.totalMarks}</p>
        <p style="font-size: 12px; color: #999;">Generated by ExamEase</p>
      </div>
  `

  // Table of Contents
  html += `
    <div style="margin-bottom: 30px; padding: 15px; background: #f5f5f5; border-radius: 8px;">
      <h3 style="margin-top: 0;">Table of Contents</h3>
      <ul style="list-style: none; padding: 0;">
  `
  content.sections.forEach((section, idx) => {
    html += `<li style="padding: 5px 0;">${idx + 1}. ${section.name} (${section.marks} marks)</li>`
  })
  html += `</ul></div>`

  // Sections
  content.sections.forEach((section, sectionIdx) => {
    html += `
      <div style="margin-bottom: 30px;">
        <h2 style="border-bottom: 1px solid #ddd; padding-bottom: 10px;">
          ${section.name}
          <span style="font-size: 14px; color: #666; font-weight: normal;"> (${section.marks} marks)</span>
        </h2>
    `

    section.questions.forEach((q, qIdx) => {
      html += `
        <div style="margin-bottom: 20px; padding: 15px; background: #fafafa; border-radius: 8px; border-left: 3px solid #4f46e5;">
          <p style="margin: 0 0 10px 0;">
            <strong>Q${sectionIdx + 1}.${qIdx + 1}.</strong> ${q.text}
            ${q.marks ? `<span style="float: right; color: #666;">[${q.marks} marks]</span>` : ""}
          </p>
          ${q.answer ? `
            <div style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 4px;">
              <strong>Answer:</strong> ${q.answer}
            </div>
          ` : ""}
        </div>
      `
    })

    html += `</div>`
  })

  // Formulas
  if (content.formulas && content.formulas.length > 0) {
    html += `
      <div style="margin-bottom: 30px; padding: 20px; background: #fff3e0; border-radius: 8px;">
        <h3 style="margin-top: 0;">Important Formulas</h3>
        <ul>
    `
    content.formulas.forEach((formula) => {
      html += `<li style="padding: 5px 0;">${formula}</li>`
    })
    html += `</ul></div>`
  }

  // Tips
  if (content.tips && content.tips.length > 0) {
    html += `
      <div style="margin-bottom: 30px; padding: 20px; background: #e3f2fd; border-radius: 8px;">
        <h3 style="margin-top: 0;">Exam Tips</h3>
        <ul>
    `
    content.tips.forEach((tip) => {
      html += `<li style="padding: 5px 0;">${tip}</li>`
    })
    html += `</ul></div>`
  }

  // Footer
  html += `
      <div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; color: #999; font-size: 12px;">
        <p>ExamEase - Smart Study & Exam Companion</p>
        <p>Generated on ${new Date().toLocaleDateString()}</p>
      </div>
    </div>
  `

  return { success: true, html }
}

// Generate question bank PDF data
export async function generateQuestionBankPDFContent(filters?: {
  difficulty?: string
  type?: string
  topic?: string
}) {
  const sessionId = await getOrCreateSession()

  const where: Record<string, unknown> = { sessionId }

  if (filters?.difficulty && filters.difficulty !== "all") {
    where.difficulty = filters.difficulty
  }
  if (filters?.type && filters.type !== "all") {
    where.type = filters.type
  }
  if (filters?.topic) {
    where.topic = { contains: filters.topic }
  }

  const questions = await prisma.question.findMany({
    where,
    orderBy: [{ topic: "asc" }, { difficulty: "asc" }],
    include: {
      sourceDoc: {
        select: { originalName: true },
      },
    },
  })

  // Group questions by topic
  const groupedQuestions: Record<string, typeof questions> = {}
  for (const q of questions) {
    const topic = q.topic || "General"
    if (!groupedQuestions[topic]) {
      groupedQuestions[topic] = []
    }
    groupedQuestions[topic].push(q)
  }

  return {
    success: true,
    data: {
      title: "Question Bank",
      totalQuestions: questions.length,
      filters,
      groupedQuestions,
      generatedAt: new Date().toISOString(),
    },
  }
}

// Update prep pack with PDF path after client-side generation
export async function updatePrepPackPDFPath(prepPackId: string, pdfPath: string) {
  const sessionId = await getOrCreateSession()

  await prisma.prepPack.updateMany({
    where: { id: prepPackId, sessionId },
    data: { pdfPath, status: "exported" },
  })

  revalidatePath("/prep-pack")
  return { success: true }
}
